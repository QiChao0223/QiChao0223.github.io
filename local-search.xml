<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mpc</title>
    <link href="/2024/03/14/mpc/"/>
    <url>/2024/03/14/mpc/</url>
    
    <content type="html"><![CDATA[<h2 id="MPC构造分类流派："><a href="#MPC构造分类流派：" class="headerlink" title="MPC构造分类流派："></a>MPC构造分类流派：</h2><ol><li>Yao‘s GC（混淆电路）</li><li>SPDZ（算数电路）</li><li>GMW（布尔电路）</li><li>ABY（share转换）</li><li>HE（同态）</li></ol><h2 id="论文合集："><a href="#论文合集：" class="headerlink" title="论文合集："></a>论文合集：</h2><p>《ABY – A Framework for Efficient Mixed-Protocol Secure Two-Party Computation》 <code>[原文链接](https://encrypto.de/papers/DSZ15.pdf)</code></p><p><code>Abstract：</code>安全计算使相互不信任的各方能够在私有输入上共同评估函数，而不透露函数的输出以外的任何东西。半诚实模型中的通用安全计算协议已被广泛研究，并且已经进化了几种最佳实践。在这项工作中，我们设计并实现了一个混合协议框架，称为<code>ABY</code>，它有效地结合了基于算术共享、布尔共享和姚氏乱码电路的安全计算方案，并在安全的两方计算中提供了可用的最佳实践解决方案。我们的框架允许预先计算几乎所有的加密操作，并在基于预先计算的不经意传输扩展的安全计算方案之间提供新颖、高效的转换。ABY 支持几个标准操作，从我们的基准测试中，我们推断了对安全计算协议高效设计的新见解，最突出的是，基于不经意传输的乘法比基于同态加密的乘法更有效。我们使用 ABY 为三个示例应用程序（私有集交集、生物特征匹配和模幂）构建混合协议，并表明它们比使用单个协议更有效。</p><p><code>特点:</code></p><ul><li>两方计算框架</li><li>半诚实敌手</li><li>乘法使用 <code>Beaver</code> 三元组，三元组使用<code>同态</code>（<code>DGK</code>和<code>Paillier</code>）和<code>OT</code>两种方式生成</li></ul><p><img src="https://typora-1306204209.cos.ap-nanjing.myqcloud.com/typora/image-20240314102728157.png" alt="image-20240314102728157"></p>]]></content>
    
    
    
    <tags>
      
      <tag>论文合集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字签名</title>
    <link href="/2024/01/14/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    <url>/2024/01/14/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<p>一些数字签名</p><span id="more"></span><h1 id="Schnorr签名算法"><a href="#Schnorr签名算法" class="headerlink" title="Schnorr签名算法"></a>Schnorr签名算法</h1><p>（一）、秘钥生成</p><ul><li>选择一条椭圆曲线$E_p(a,b)$ 和基点$G$</li><li>选择私钥$d_A$ （$d_a &lt; n $， $n$是 $G$ 的阶），利用基点$G$计算公钥$Q_A = d_A \cdot G$</li></ul><p>（二）、签名算法</p><ul><li>随机选择一个整数$K$（$K$ &lt; n）</li><li>计算$R = K \cdot G = (x_1, y_1)$ </li><li>$\sigma = K + hash(Q_A|| m || R) \cdot d_A$</li><li>签名$(\sigma, R)$</li></ul><p>（三）、验证算法</p><ul><li>验证等式：$\sigma \cdot G = hash(Q_A|| m || R) \cdot Q_A + R$</li><li>如果等式成立输出 $1$，否则输出 $0$</li></ul><h1 id="SM2签名"><a href="#SM2签名" class="headerlink" title="SM2签名"></a>SM2签名</h1><p>$d_A$：用户 $A$ 的私钥</p><p>$P_A$：用户 $A$ 的公钥</p><p>$ID_A$：用户 $A$ 的可辨别标识</p><p>$n$：基点 $G$ 的阶</p><p>（一）、签名算法</p><blockquote><p>设待签名的消息为$M$，$Z<em>A=H</em>{256}(ENTL_A\parallel ID_A\parallel a\parallel b\parallel x_G\parallel y_G\parallel x_A\parallel y_A)$，其中$a、b$为椭圆曲线参数，$G$的坐标$x_G、y_G$和$P_A$的坐标$x_A、y_A$</p></blockquote><ol><li>置$\overline{M}=Z_A\parallel M$</li><li>计算$e=H_v(\overline{M})$</li><li>用随机数发生器产生随机数$k \in [1, n-1]$</li><li>计算椭曲线点$(x_1,y_1) = k \cdot G$</li><li>计算$r = e + x_1$ mod  $n$，若$r = 0$ 或 $r + k = n$，则返回第三步</li><li>计算$s = \frac{k- r \cdot d_A}{1+ d_A}$ mod $n$，若$s = 0$，则返回第三步</li><li>消息的签名为$(r, s)$</li></ol><p>（二）、验证算法</p><blockquote><p>收到的消息 $M’$ 及其数字签名 $(r’,s’)$</p></blockquote><ol><li>检验 $r’ \in [1, n-1]$ 是否成立，若不成立则验证不通过</li><li>检验$s’ \in [1, n-1]$ 是否成立，若不成立则验证不通过</li><li>置$\overline{M}’=Z_A\parallel M’$</li><li>计算$e’=H_v(\overline{M}’)$</li><li>计算 $t = r’ + s’$ mod $n$，若$t = 0$，则验证不通过</li><li>计算椭圆曲线点$(x_1’, x_2’) = s’ \cdot G + t \cdot P_A$</li><li>计算$R = (e’ + x_1’) $ mod $n$，检验 $R = r’$ 是否成立，若成立则验证通过，否则验证不通过</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数字签名</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

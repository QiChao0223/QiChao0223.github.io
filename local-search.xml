<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Orca</title>
    <link href="/2024/01/21/Orca/"/>
    <url>/2024/01/21/Orca/</url>
    
    <content type="html"><![CDATA[<p>Orca: FSS-based Secure Training and Inference with GPUs</p><!----><h1>Preliminaries</h1><h2 id="Function-Secret-Sharing（FSS）">Function Secret Sharing（FSS）</h2><h3 id="定义：">定义：</h3><p>一个 <code>FSS scheme</code>由一对称为 <code>Gen</code> 和 <code>Eval</code>的算法组成。</p><p><code>Gen</code>：把秘密函数 $f：\mathbb{G}^{in} \to \mathbb{G}^{out}$  分割成一对函数  $f_0$ 和  $f_1$ （或者是 $k_0$和$k_1$）</p><p><code>Eval</code>：$\sigma \in {0, 1}$ 是身份标识符，在给定输入 $x \in \mathbb{G}^{in}$  后，<code>Eval</code>评估函数  $f_{\sigma}$</p><p><img src="https://typora-1306204209.cos.ap-nanjing.myqcloud.com/typora/image-20240123093231248.png" alt="FSS"></p><p><img src="https://typora-1306204209.cos.ap-nanjing.myqcloud.com/typora/image-20240122151856529.png" alt="FSS"></p><h3 id="举例：">举例：</h3><p><strong>可以参考这篇文章</strong>《<a href="https://zhuanlan.zhihu.com/p/647139387">函数秘密共享（一）</a>》</p><h1>Building Blcoks</h1><h3 id="Select-Function">Select Function</h3><p>$$<br>select_n:{0,1} \times \mathbb{U}_N \to  \mathbb{U}<em>N \<br>select</em>{n}(s,x) = s \cdot x<br>$$</p><p>输入：选择比特 $s \in {0,1} $ 和 $n-bit$ 的负荷$x\in \mathbb{U}_N$</p><p>输出：如果$s=1$，输出$x$；否则输出 $0$</p><h3 id="Offset-function-for-select-n">Offset function for $select_n$</h3><p>$$<br>select_{n}^{[(r_{1}^{in},r_{2}^{in}),r^{out}]} (\hat{s},\hat{x}) = (\hat{s} - r_{1}^{in} + 2 \cdot 1 {\hat{s} &lt; r_{1}^{in}} ) \cdot (\hat{x} - r_{2}^{in}) + r^{out}\pmod{ 2 ^{n} }\<br>= s \cdot x + r^{out} \pmod {2 ^n}<br>$$</p><p>其中$r_{1}^{in}$ 是选择比特 $s$ 的掩码，$r_{2}^{in}$ 是 $x$ 的掩码，$r^{out}$ 是$s \cdot x$ 结果的掩码</p><blockquote><p>$(\hat{s} - r_{1}^{in} + 2 \cdot 1 {\hat{s} &lt; r_{1}^{in}} ) $ 为什么等于 $s$ ？</p></blockquote><table><thead><tr><th style="text-align:center">$s$</th><th style="text-align:center">$r_{1}^{in}$</th><th style="text-align:center">$\hat{s}$</th><th style="text-align:center">$\hat{s} - r_{1}^{in} + 2 \cdot 1 {\hat{s} &lt; r_{1}^{in}}$</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><p>继续拆分上面的公式：<br>$$<br>select_{n}^{[(r_{1}^{in},r_{2}^{in}),r^{out}]} (\hat{s},\hat{x}) = \hat{s} \cdot \hat{x}- r_{1}\cdot \hat{x} - \hat{s}\cdot r_{2}^{in} +r_{1}^{in} \cdot r_2^{in} + 2 \cdot 1{\hat{s} = 0   ,r_{1}^{in}=1}\cdot (\hat{x} - r_{2}^{in}) + r^{out} \pmod{2^n}<br>$$<br><img src="https://typora-1306204209.cos.ap-nanjing.myqcloud.com/typora/image-20240123110123795.png" alt="select protocol"></p>]]></content>
    
    
    
    <tags>
      
      <tag>mpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aby2</title>
    <link href="/2024/01/18/aby2/"/>
    <url>/2024/01/18/aby2/</url>
    
    <content type="html"><![CDATA[<p>ABY2.0: Improved Mixed-Protocol Secure Two-Party Computation</p><span id="more"></span><h1>Preliminaries</h1><p><code>两方</code>：$\mathcal{P}={P_0,P_1}$</p><p><code>scalar dot product</code>：2个长度为 $n$ 的向量 $\vec{a}$和$\vec{b}$，$\vec{a}\odot\vec{b}=\boldsymbol{\sum_{j=1}^na_jb_j}$，其中$a_$ 和$b_j$表示向量 $\vec{a}$  和 $\vec{b}$ 的第 $j$ 个元素</p><p><code>补码</code>：$\overline{\mathrm{u}} = 1 \oplus u$</p><p><code>matric mul</code>：矩阵乘，$\mathbf{A}\circ\mathbf{B}$，其中 $A$ 和 $B$ 是两个矩阵</p>]]></content>
    
    
    
    <tags>
      
      <tag>mpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aby</title>
    <link href="/2024/01/17/aby/"/>
    <url>/2024/01/17/aby/</url>
    
    <content type="html"><![CDATA[<p>ABY – A Framework for Efficient Mixed-Protocol Secure Two-Party Computation</p><span id="more"></span><p>$x$是1 bit</p><blockquote><p>yao share</p></blockquote><p>当$x = 0$ ，$P_1$：$x_{1}^Y = k_x = k_0 \oplus x R = k_0$</p><p>当$x = 1$ ，$P_1$：$x_{1}^Y = k_x = k_0 \oplus x R = k_0 \oplus R$</p><blockquote><p>yao reconstruct</p></blockquote><p>$\pi = \langle x \rangle <em>{1-i} ^Y [0] = k</em>{1-i}[0]$</p><p>$\pi \oplus \langle x \rangle_{i} ^ Y [0] = k_{1-i}[0] \oplus (k_{1-i}[0] \oplus xR)[0] = 0 \oplus x R = x R = x$</p><p>其中$R$是一个$\kappa$-bit的字符串，并且$R[0] = 1$</p><blockquote><p>B2A：$l$ bit 的boolen share $\langle x \rangle  ^ B $ 转成 an arithmetic share $\langle x \rangle  ^ A $</p></blockquote><ol><li><p>简单的方案，在 <code>Boolean subtraction circuit</code>中</p><p>$P_0$：输入 $\langle x \rangle _ {0} ^ B $ 和随机数 $r \in _R {0,1}^{\ell}$，获得 $\langle x \rangle _ {0} ^ A = r $</p><p>$P_1$：输入 $\langle x \rangle _ {1} ^ B $ ，获得 $\langle x \rangle _ {1} ^ A = x - r $</p><p>评估这样的减法电路需要 $O(\ell\log_2\ell)$ size 和 $O(\log_2\ell)$ depth  或者 $O(\ell)$ 的size 和 depth</p></li><li><p>优化后方案，使用 <code>OT</code>，类似算术乘法三元组</p><p>$P_0$：<code>sender</code></p><p>$P_1$：<code>receiver</code></p><p>在第 $i-th$ 轮 <code>OT</code></p><p>​$P_0$随机选择$r_i \in <em>R {0,1} ^ \ell$，并输入 $({s</em>{i,0}},s_{i,1})$，其中$s_{i,0}=(1-\langle x \rangle_{0}^{B}[i])\cdot 2 ^ {i} - r_{i}$  和 $s_{i,1}:=:\langle x\rangle_0^B[i]\cdot2^i:-:r_i$</p><p>​$1-\langle x \rangle_{0}^{B}[i] = \langle x \rangle_{1}^{B}[i]$</p><p>​$P_1$输入选择比特 $\langle x \rangle_{i} ^{B}[i] $，接收 $s_{\langle x\rangle_1^B[i]}=\left(\langle x\rangle_0^B[i]\oplus\langle x\rangle_1^B[i]\right) \cdot 2^i - r_{i}$</p><p>​当$\langle x \rangle_{1} ^{B}[i] =1$ 时，$s_{\langle x\rangle_1^B[i]}=\left(\langle x\rangle_0^B[i]\oplus 1 \right) \cdot 2^i - r_{i} = (1-\langle x \rangle_{0}^{B}[i]) \cdot 2 ^{i} - r _{i}$</p><p>​当$\langle x \rangle_{1} ^{B}[i] =0$ 时，$s_{\langle x\rangle_1^B[i]}=\left(\langle x\rangle_0^B[i]  \right) \cdot 2^i - r_{i} $</p><p>最终，</p><p>$P_0$计算出：$\langle x\rangle_{0}^{A}=\sum_{i=1}^{\ell}r_{i}$</p><p>$P_1$计算出：$\langle x\rangle_1^A=\sum_{i=1}^{\ell}s_{\langle x\rangle_1^B[i]}=\sum_{i=1}^{\ell}\left(\langle x\rangle_0^B[i]\oplus\langle x\rangle_1^B[i]\right)\cdot 2^i-\sum_{i=1}^{\ell}r_i=\sum_{i=1}^{\ell}x[i]\cdot2^i-\sum_{i=1}^{\ell}r_i=x-\langle x\rangle_0^A$</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字签名</title>
    <link href="/2024/01/14/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    <url>/2024/01/14/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<p>一些数字签名</p><span id="more"></span><h1>Schnorr签名算法</h1><p>（一）、秘钥生成</p><ul><li>选择一条椭圆曲线$E_p(a,b)$ 和基点$G$</li><li>选择私钥$d_A$ （$d_a &lt; n $， $n$是 $G$ 的阶），利用基点$G$计算公钥$Q_A = d_A \cdot G$</li></ul><p>（二）、签名算法</p><ul><li>随机选择一个整数$K$（$K$ &lt; n）</li><li>计算$R = K \cdot G = (x_1, y_1)$</li><li>$\sigma = K + hash(Q_A|| m || R) \cdot d_A$</li><li>签名$(\sigma, R)$</li></ul><p>（三）、验证算法</p><ul><li>验证等式：$\sigma \cdot G = hash(Q_A|| m || R) \cdot Q_A + R$</li><li>如果等式成立输出 $1$，否则输出 $0$</li></ul><h1>SM2签名</h1><p>$d_A$：用户 $A$ 的私钥</p><p>$P_A$：用户 $A$ 的公钥</p><p>$ID_A$：用户 $A$ 的可辨别标识</p><p>$n$：基点 $G$ 的阶</p><p>（一）、签名算法</p><blockquote><p>设待签名的消息为$M$，$Z_A=H_{256}(ENTL_A\parallel ID_A\parallel a\parallel b\parallel x_G\parallel y_G\parallel x_A\parallel y_A)$，其中$a、b$为椭圆曲线参数，$G$的坐标$x_G、y_G$和$P_A$的坐标$x_A、y_A$</p></blockquote><ol><li>置$\overline{M}=Z_A\parallel M$</li><li>计算$e=H_v(\overline{M})$</li><li>用随机数发生器产生随机数$k \in [1, n-1]$</li><li>计算椭曲线点$(x_1,y_1) = k \cdot G$</li><li>计算$r = e + x_1$ mod  $n$，若$r = 0$ 或 $r + k = n$，则返回第三步</li><li>计算$s = \frac{k- r \cdot d_A}{1+ d_A}$ mod $n$，若$s = 0$，则返回第三步</li><li>消息的签名为$(r, s)$</li></ol><p>（二）、验证算法</p><blockquote><p>收到的消息 $M’$ 及其数字签名 $(r’,s’)$</p></blockquote><ol><li>检验 $r’ \in [1, n-1]$ 是否成立，若不成立则验证不通过</li><li>检验$s’ \in [1, n-1]$ 是否成立，若不成立则验证不通过</li><li>置$\overline{M}‘=Z_A\parallel M’$</li><li>计算$e’=H_v(\overline{M}')$</li><li>计算 $t = r’ + s’$ mod $n$，若$t = 0$，则验证不通过</li><li>计算椭圆曲线点$(x_1’, x_2’) = s’ \cdot G + t \cdot P_A$</li><li>计算$R = (e’ + x_1’) $ mod $n$，检验 $R = r’$ 是否成立，若成立则验证通过，否则验证不通过</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数字签名</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

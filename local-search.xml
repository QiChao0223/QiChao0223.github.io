<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mpc</title>
    <link href="/2024/03/14/mpc/"/>
    <url>/2024/03/14/mpc/</url>
    
    <content type="html"><![CDATA[<h2 id="mpc构造分类流派">MPC构造分类流派：</h2><ol type="1"><li>Yao‘s GC（混淆电路）</li><li>SPDZ（算数电路）</li><li>GMW（布尔电路）</li><li>ABY（share转换）</li><li>HE（同态）</li></ol><h2 id="mpc-friendly-relu">mpc-friendly ReLU</h2><p><code>一些路线：</code></p><ol type="1"><li>replace ReLUs with MPC-friendly approximations</li><li>search for network backbones with a minimal number of ReLUs</li><li>hardware-aware ReLU-reduced networks to achieve betterlatencies</li><li>derive inspiration from network pruning</li></ol><figure><imgsrc="https://typora-1306204209.cos.ap-nanjing.myqcloud.com/typora/image-20240314103600017.png"alt="image-20240314103600017" /><figcaption aria-hidden="true">image-20240314103600017</figcaption></figure><h2 id="论文合集">论文合集：</h2><p>《ABY – A Framework for Efficient Mixed-Protocol Secure Two-PartyComputation》<code>[原文链接](https://encrypto.de/papers/DSZ15.pdf)</code></p><p><code>Abstract：</code>安全计算使相互不信任的各方能够在私有输入上共同评估函数，而不透露函数的输出以外的任何东西。半诚实模型中的通用安全计算协议已被广泛研究，并且已经进化了几种最佳实践。在这项工作中，我们设计并实现了一个混合协议框架，称为<code>ABY</code>，它有效地结合了基于算术共享、布尔共享和姚氏乱码电路的安全计算方案，并在安全的两方计算中提供了可用的最佳实践解决方案。我们的框架允许预先计算几乎所有的加密操作，并在基于预先计算的不经意传输扩展的安全计算方案之间提供新颖、高效的转换。ABY支持几个标准操作，从我们的基准测试中，我们推断了对安全计算协议高效设计的新见解，最突出的是，基于不经意传输的乘法比基于同态加密的乘法更有效。我们使用ABY为三个示例应用程序（私有集交集、生物特征匹配和模幂）构建混合协议，并表明它们比使用单个协议更有效。</p><p><code>特点:</code></p><ul><li>两方计算框架</li><li>半诚实敌手</li><li>乘法使用 <code>Beaver</code>三元组，三元组使用<code>同态</code>（<code>DGK</code>和<code>Paillier</code>）和<code>OT</code>两种方式生成</li></ul><figure><imgsrc="https://typora-1306204209.cos.ap-nanjing.myqcloud.com/typora/image-20240314102728157.png"alt="image-20240314102728157" /><figcaption aria-hidden="true">image-20240314102728157</figcaption></figure><p>《ABY2.0: Improved Mixed-Protocol Secure Two-PartyComputation》<code>[原文链接](https://eprint.iacr.org/2020/1225.pdf)</code></p><p><code>Abstract：</code>安全多方计算（MPC）允许一组相互不信任的各方在维护输入隐私的同时，对其私人输入联合评估函数。在这项工作中，我们改进了环上的半诚实安全两方计算（2PC），重点是在线阶段的效率。我们提出了一种高效的混合协议框架，其性能优于ABY最先进的2PC框架。此外，我们将我们的技术扩展到多输入乘法门，而不会膨胀在线通信，即它保持独立于扇入。在此过程中，我们为标量积、矩阵乘法、比较、最大池和等式测试等几个原语构建了有效的协议。我们的标量乘积的在线通信是两个环元素，与向量维度无关，这是2PC文献中首次实现的特征。我们的新协议集的实用性通过四个应用程序展示：i）AESS-box，ii）基于电路的私用集交集，iii）生物特征匹配，以及iv）保密机器学习（PPML）。最值得注意的是，对于PPML，我们在LAN和WAN网络上实现并基准测试逻辑回归和神经网络的训练和推理。对于训练，我们在SecureML（Mohaselet al.，IEEES&amp;P’17）上改进了在线运行时间（局域网和广域网），范围为1.5×–6.1×，而对于推理，改进范围为2.5×–754.3×</p><p><code>特点:</code></p><ul><li>两方计算框架</li><li>半诚实敌手</li></ul><figure><imgsrc="https://typora-1306204209.cos.ap-nanjing.myqcloud.com/typora/image-20240314112145443.png"alt="image-20240314112145443" /><figcaption aria-hidden="true">image-20240314112145443</figcaption></figure><figure><imgsrc="https://typora-1306204209.cos.ap-nanjing.myqcloud.com/typora/image-20240314112041439.png"alt="image-20240314112041439" /><figcaption aria-hidden="true">image-20240314112041439</figcaption></figure><p>相较于ABY的一些改进：</p><ol type="1"><li>ABY转化中在线阶段需要大量OT，ABY2.0中OT都在预计算完成，因此ABY2.0转化中在线效率提升很多（除了Y2B）</li><li>预计算阶段生成三元组)的方法和ABY一样。对比ABY，另一个提升在于多输入乘法只需要一轮通信而且通信量只有ℓ 比特。</li><li>ABY2.0基于B2A做了三种比较高效转化</li><li>和ABY相比，ABY2.0对于电路性能进行了进一步的提升，大部分开销转移到了预计算阶段。这主要归功于新的sharingsemantics的提出。但是，预计算的开销却增加到了指数级别（多输入乘法门）。进一步，ABY2.0的计算需要对事先对电路的结构进行全局的扫描生成乘法关联元组，这比ABY的要求更加严格。</li></ol><figure><imgsrc="https://typora-1306204209.cos.ap-nanjing.myqcloud.com/typora/image-20240314112416104.png"alt="image-20240314112416104" /><figcaption aria-hidden="true">image-20240314112416104</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>论文合集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字签名</title>
    <link href="/2024/01/14/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    <url>/2024/01/14/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<p>一些数字签名</p><span id="more"></span><h1 id="schnorr签名算法">Schnorr签名算法</h1><p>（一）、秘钥生成</p><ul><li>选择一条椭圆曲线<span class="math inline">\(E_p(a,b)\)</span>和基点<span class="math inline">\(G\)</span></li><li>选择私钥<span class="math inline">\(d_A\)</span> （$d_a &lt; n $，<span class="math inline">\(n\)</span>是 <spanclass="math inline">\(G\)</span> 的阶），利用基点<spanclass="math inline">\(G\)</span>计算公钥<span class="math inline">\(Q_A= d_A \cdot G\)</span></li></ul><p>（二）、签名算法</p><ul><li>随机选择一个整数<span class="math inline">\(K\)</span>（<spanclass="math inline">\(K\)</span> &lt; n）</li><li>计算<span class="math inline">\(R = K \cdot G = (x_1,y_1)\)</span></li><li><span class="math inline">\(\sigma = K + hash(Q_A|| m || R) \cdotd_A\)</span></li><li>签名<span class="math inline">\((\sigma, R)\)</span></li></ul><p>（三）、验证算法</p><ul><li>验证等式：<span class="math inline">\(\sigma \cdot G = hash(Q_A|| m|| R) \cdot Q_A + R\)</span></li><li>如果等式成立输出 <span class="math inline">\(1\)</span>，否则输出<span class="math inline">\(0\)</span></li></ul><h1 id="sm2签名">SM2签名</h1><p><span class="math inline">\(d_A\)</span>：用户 <spanclass="math inline">\(A\)</span> 的私钥</p><p><span class="math inline">\(P_A\)</span>：用户 <spanclass="math inline">\(A\)</span> 的公钥</p><p><span class="math inline">\(ID_A\)</span>：用户 <spanclass="math inline">\(A\)</span> 的可辨别标识</p><p><span class="math inline">\(n\)</span>：基点 <spanclass="math inline">\(G\)</span> 的阶</p><p>（一）、签名算法</p><blockquote><p>设待签名的消息为<span class="math inline">\(M\)</span>，<spanclass="math inline">\(Z_A=H_{256}(ENTL_A\parallel ID_A\parallela\parallel b\parallel x_G\parallel y_G\parallel x_A\parallely_A)\)</span>，其中<spanclass="math inline">\(a、b\)</span>为椭圆曲线参数，<spanclass="math inline">\(G\)</span>的坐标<spanclass="math inline">\(x_G、y_G\)</span>和<spanclass="math inline">\(P_A\)</span>的坐标<spanclass="math inline">\(x_A、y_A\)</span></p></blockquote><ol type="1"><li>置<span class="math inline">\(\overline{M}=Z_A\parallelM\)</span></li><li>计算<span class="math inline">\(e=H_v(\overline{M})\)</span></li><li>用随机数发生器产生随机数<span class="math inline">\(k \in [1,n-1]\)</span></li><li>计算椭曲线点<span class="math inline">\((x_1,y_1) = k \cdotG\)</span></li><li>计算<span class="math inline">\(r = e + x_1\)</span> mod <spanclass="math inline">\(n\)</span>，若<span class="math inline">\(r =0\)</span> 或 <span class="math inline">\(r + k =n\)</span>，则返回第三步</li><li>计算<span class="math inline">\(s = \frac{k- r \cdot d_A}{1+d_A}\)</span> mod <span class="math inline">\(n\)</span>，若<spanclass="math inline">\(s = 0\)</span>，则返回第三步</li><li>消息的签名为<span class="math inline">\((r, s)\)</span></li></ol><p>（二）、验证算法</p><blockquote><p>收到的消息 <span class="math inline">\(M&#39;\)</span> 及其数字签名<span class="math inline">\((r&#39;,s&#39;)\)</span></p></blockquote><ol type="1"><li>检验 <span class="math inline">\(r&#39; \in [1, n-1]\)</span>是否成立，若不成立则验证不通过</li><li>检验<span class="math inline">\(s&#39; \in [1, n-1]\)</span>是否成立，若不成立则验证不通过</li><li>置<span class="math inline">\(\overline{M}&#39;=Z_A\parallelM&#39;\)</span></li><li>计算<spanclass="math inline">\(e&#39;=H_v(\overline{M}&#39;)\)</span></li><li>计算 <span class="math inline">\(t = r&#39; + s&#39;\)</span> mod<span class="math inline">\(n\)</span>，若<span class="math inline">\(t= 0\)</span>，则验证不通过</li><li>计算椭圆曲线点<span class="math inline">\((x_1&#39;, x_2&#39;) =s&#39; \cdot G + t \cdot P_A\)</span></li><li>计算$R = (e' + x_1') $ mod <spanclass="math inline">\(n\)</span>，检验 <span class="math inline">\(R =r&#39;\)</span> 是否成立，若成立则验证通过，否则验证不通过</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数字签名</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

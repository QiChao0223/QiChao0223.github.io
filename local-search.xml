<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>aby2</title>
    <link href="/2024/01/18/aby2/"/>
    <url>/2024/01/18/aby2/</url>
    
    <content type="html"><![CDATA[<p>ABY2.0: Improved Mixed-Protocol Secure Two-Party Computation</p><span id="more"></span><h1 id="preliminaries">Preliminaries</h1><p><code>两方</code>：<spanclass="math inline">\(\mathcal{P}=\{P_0,P_1\}\)</span></p><p><code>scalar dot product</code>：2个长度为 <spanclass="math inline">\(n\)</span> 的向量 <spanclass="math inline">\(\vec{a}\)</span>和<spanclass="math inline">\(\vec{b}\)</span>，<spanclass="math inline">\(\vec{a}\odot\vec{b}=\boldsymbol{\sum_{j=1}^na_jb_j}\)</span>，其中<spanclass="math inline">\(a_\)</span> 和<spanclass="math inline">\(b_j\)</span>表示向量 <spanclass="math inline">\(\vec{a}\)</span> 和 <spanclass="math inline">\(\vec{b}\)</span> 的第 <spanclass="math inline">\(j\)</span> 个元素</p><p><code>补码</code>：<span class="math inline">\(\overline{\mathrm{u}}= 1 \oplus u\)</span></p><p><code>matric mul</code>：矩阵乘，<spanclass="math inline">\(\mathbf{A}\circ\mathbf{B}\)</span>，其中 <spanclass="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 是两个矩阵</p>]]></content>
    
    
    
    <tags>
      
      <tag>mpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aby</title>
    <link href="/2024/01/17/aby/"/>
    <url>/2024/01/17/aby/</url>
    
    <content type="html"><![CDATA[<p>ABY – A Framework for Efficient Mixed-Protocol Secure Two-PartyComputation</p><span id="more"></span><p><span class="math inline">\(x\)</span>是1 bit</p><blockquote><p>yao share</p></blockquote><p>当<span class="math inline">\(x = 0\)</span> ，<spanclass="math inline">\(P_1\)</span>：<span class="math inline">\(x_{1}^Y= k_x = k_0 \oplus x R = k_0\)</span></p><p>当<span class="math inline">\(x = 1\)</span> ，<spanclass="math inline">\(P_1\)</span>：<span class="math inline">\(x_{1}^Y= k_x = k_0 \oplus x R = k_0 \oplus R\)</span></p><blockquote><p>yao reconstruct</p></blockquote><p><span class="math inline">\(\pi = \langle x \rangle _{1-i} ^Y [0] =k_{1-i}[0]\)</span></p><p><span class="math inline">\(\pi \oplus \langle x \rangle_{i} ^ Y [0]= k_{1-i}[0] \oplus (k_{1-i}[0] \oplus xR)[0] = 0 \oplus x R = x R =x\)</span></p><p>其中<span class="math inline">\(R\)</span>是一个<spanclass="math inline">\(\kappa\)</span>-bit的字符串，并且<spanclass="math inline">\(R[0] = 1\)</span></p><blockquote><p>B2A：<span class="math inline">\(l\)</span> bit 的boolen share $x ^ B$ 转成 an arithmetic share $x ^ A $</p></blockquote><ol type="1"><li><p>简单的方案，在 <code>Boolean subtraction circuit</code>中</p><p><span class="math inline">\(P_0\)</span>：输入 $x _ {0} ^ B $和随机数 <span class="math inline">\(r \in _R\{0,1\}^{\ell}\)</span>，获得 $x _ {0} ^ A = r $</p><p><span class="math inline">\(P_1\)</span>：输入 $x _ {1} ^ B $ ，获得$x _ {1} ^ A = x - r $</p><p>评估这样的减法电路需要 <spanclass="math inline">\(O(\ell\log_2\ell)\)</span> size 和 <spanclass="math inline">\(O(\log_2\ell)\)</span> depth 或者 <spanclass="math inline">\(O(\ell)\)</span> 的size 和 depth</p></li><li><p>优化后方案，使用 <code>OT</code>，类似算术乘法三元组</p><p><span class="math inline">\(P_0\)</span>：<code>sender</code></p><p><span class="math inline">\(P_1\)</span>：<code>receiver</code></p><p>在第 <span class="math inline">\(i-th\)</span> 轮 <code>OT</code></p><p>​ <span class="math inline">\(P_0\)</span>随机选择<spanclass="math inline">\(r_i \in _R \{0,1\} ^ \ell\)</span>，并输入 <spanclass="math inline">\(({s_{i,0}},s_{i,1})\)</span>，其中<spanclass="math inline">\(s_{i,0}=(1-\langle x \rangle_{0}^{B}[i])\cdot 2 ^{i} - r_{i}\)</span> 和 <span class="math inline">\(s_{i,1}\:=\:\langlex\rangle_0^B[i]\cdot2^i\:-\:r_i\)</span></p><p>​ <span class="math inline">\(1-\langle x \rangle_{0}^{B}[i] = \langlex \rangle_{1}^{B}[i]\)</span></p><p>​ <span class="math inline">\(P_1\)</span>输入选择比特 $x _{i} ^{B}[i]$，接收 <span class="math inline">\(s_{\langlex\rangle_1^B[i]}=\left(\langle x\rangle_0^B[i]\oplus\langlex\rangle_1^B[i]\right) \cdot 2^i - r_{i}\)</span></p><p>​ 当<span class="math inline">\(\langle x \rangle_{1} ^{B}[i]=1\)</span> 时，<span class="math inline">\(s_{\langlex\rangle_1^B[i]}=\left(\langle x\rangle_0^B[i]\oplus 1 \right) \cdot 2^i- r_{i} = (1-\langle x \rangle_{0}^{B}[i]) \cdot 2 ^{i} - r_{i}\)</span></p><p>​ 当<span class="math inline">\(\langle x \rangle_{1} ^{B}[i]=0\)</span> 时，$s_{x_1^B[i]}=(x<em>0^B[i] ) ^i - r</em>{i} $</p><p>最终，</p><p><span class="math inline">\(P_0\)</span>计算出：<spanclass="math inline">\(\langlex\rangle_{0}^{A}=\sum_{i=1}^{\ell}r_{i}\)</span></p><p><span class="math inline">\(P_1\)</span>计算出：<spanclass="math inline">\(\langle x\rangle_1^A=\sum_{i=1}^{\ell}s_{\langlex\rangle_1^B[i]}=\sum_{i=1}^{\ell}\left(\langlex\rangle_0^B[i]\oplus\langle x\rangle_1^B[i]\right)\cdot2^i-\sum_{i=1}^{\ell}r_i=\sum_{i=1}^{\ell}x[i]\cdot2^i-\sum_{i=1}^{\ell}r_i=x-\langlex\rangle_0^A\)</span></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>截断</title>
    <link href="/2024/01/15/%E6%88%AA%E6%96%AD/"/>
    <url>/2024/01/15/%E6%88%AA%E6%96%AD/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>mpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字签名</title>
    <link href="/2024/01/14/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    <url>/2024/01/14/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<p>一些数字签名</p><span id="more"></span><h1 id="schnorr签名算法">Schnorr签名算法</h1><p>（一）、秘钥生成</p><ul><li>选择一条椭圆曲线<span class="math inline">\(E_p(a,b)\)</span>和基点<span class="math inline">\(G\)</span></li><li>选择私钥<span class="math inline">\(d_A\)</span> （$d_a &lt; n $，<span class="math inline">\(n\)</span>是 <spanclass="math inline">\(G\)</span> 的阶），利用基点<spanclass="math inline">\(G\)</span>计算公钥<span class="math inline">\(Q_A= d_A \cdot G\)</span></li></ul><p>（二）、签名算法</p><ul><li>随机选择一个整数<span class="math inline">\(K\)</span>（<spanclass="math inline">\(K\)</span> &lt; n）</li><li>计算<span class="math inline">\(R = K \cdot G = (x_1,y_1)\)</span></li><li><span class="math inline">\(\sigma = K + hash(Q_A|| m || R) \cdotd_A\)</span></li><li>签名<span class="math inline">\((\sigma, R)\)</span></li></ul><p>（三）、验证算法</p><ul><li>验证等式：<span class="math inline">\(\sigma \cdot G = hash(Q_A|| m|| R) \cdot Q_A + R\)</span></li><li>如果等式成立输出 <span class="math inline">\(1\)</span>，否则输出<span class="math inline">\(0\)</span></li></ul><h1 id="sm2签名">SM2签名</h1><p><span class="math inline">\(d_A\)</span>：用户 <spanclass="math inline">\(A\)</span> 的私钥</p><p><span class="math inline">\(P_A\)</span>：用户 <spanclass="math inline">\(A\)</span> 的公钥</p><p><span class="math inline">\(ID_A\)</span>：用户 <spanclass="math inline">\(A\)</span> 的可辨别标识</p><p><span class="math inline">\(n\)</span>：基点 <spanclass="math inline">\(G\)</span> 的阶</p><p>（一）、签名算法</p><blockquote><p>设待签名的消息为<span class="math inline">\(M\)</span>，<spanclass="math inline">\(Z_A=H_{256}(ENTL_A\parallel ID_A\parallela\parallel b\parallel x_G\parallel y_G\parallel x_A\parallely_A)\)</span>，其中<spanclass="math inline">\(a、b\)</span>为椭圆曲线参数，<spanclass="math inline">\(G\)</span>的坐标<spanclass="math inline">\(x_G、y_G\)</span>和<spanclass="math inline">\(P_A\)</span>的坐标<spanclass="math inline">\(x_A、y_A\)</span></p></blockquote><ol type="1"><li>置<span class="math inline">\(\overline{M}=Z_A\parallelM\)</span></li><li>计算<span class="math inline">\(e=H_v(\overline{M})\)</span></li><li>用随机数发生器产生随机数<span class="math inline">\(k \in [1,n-1]\)</span></li><li>计算椭曲线点<span class="math inline">\((x_1,y_1) = k \cdotG\)</span></li><li>计算<span class="math inline">\(r = e + x_1\)</span> mod <spanclass="math inline">\(n\)</span>，若<span class="math inline">\(r =0\)</span> 或 <span class="math inline">\(r + k =n\)</span>，则返回第三步</li><li>计算<span class="math inline">\(s = \frac{k- r \cdot d_A}{1+d_A}\)</span> mod <span class="math inline">\(n\)</span>，若<spanclass="math inline">\(s = 0\)</span>，则返回第三步</li><li>消息的签名为<span class="math inline">\((r, s)\)</span></li></ol><p>（二）、验证算法</p><blockquote><p>收到的消息 <span class="math inline">\(M&#39;\)</span> 及其数字签名<span class="math inline">\((r&#39;,s&#39;)\)</span></p></blockquote><ol type="1"><li>检验 <span class="math inline">\(r&#39; \in [1, n-1]\)</span>是否成立，若不成立则验证不通过</li><li>检验<span class="math inline">\(s&#39; \in [1, n-1]\)</span>是否成立，若不成立则验证不通过</li><li>置<span class="math inline">\(\overline{M}&#39;=Z_A\parallelM&#39;\)</span></li><li>计算<spanclass="math inline">\(e&#39;=H_v(\overline{M}&#39;)\)</span></li><li>计算 <span class="math inline">\(t = r&#39; + s&#39;\)</span> mod<span class="math inline">\(n\)</span>，若<span class="math inline">\(t= 0\)</span>，则验证不通过</li><li>计算椭圆曲线点<span class="math inline">\((x_1&#39;, x_2&#39;) =s&#39; \cdot G + t \cdot P_A\)</span></li><li>计算$R = (e' + x_1') $ mod <spanclass="math inline">\(n\)</span>，检验 <span class="math inline">\(R =r&#39;\)</span> 是否成立，若成立则验证通过，否则验证不通过</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数字签名</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
